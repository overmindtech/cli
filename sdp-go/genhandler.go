//go:build ignore

package main

import (
	"fmt"
	"html/template"
	"os"
	"strings"
)

type Args struct {
	Type string
}

func main() {
	fmt.Printf("Running %s go on %s\n", os.Args[0], os.Getenv("GOFILE"))

	cwd, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	fmt.Printf("  cwd = %s\n", cwd)
	fmt.Printf("  os.Args = %#v\n", os.Args)

	for _, ev := range []string{"GOARCH", "GOOS", "GOFILE", "GOLINE", "GOPACKAGE", "DOLLAR"} {
		fmt.Println("  ", ev, "=", os.Getenv(ev))
	}

	if len(os.Args) < 2 {
		panic("Missing argument, aborting")
	}

	v := Args{Type: os.Args[1]}
	t := template.New("simple")
	t, err = t.Parse(`// Code generated by "genhandler {{.Type}}"; DO NOT EDIT

package sdp

import (
	"context"

	"github.com/nats-io/nats.go"
	"go.opentelemetry.io/otel/trace"
	"github.com/overmindtech/cli/tracing"
)

func New{{.Type}}Handler(spanName string, h func(ctx context.Context, i *{{.Type}}), spanOpts ...trace.SpanStartOption) nats.MsgHandler {
	return NewOtelExtractingHandler(
		spanName,
		func(ctx context.Context, m *nats.Msg) {
			var i {{.Type}}
			err := Unmarshal(ctx, m.Data, &i)
			if err != nil {
				return
			}
			h(ctx, &i)
		},
		tracing.Tracer(),
	)
}

func NewRaw{{.Type}}Handler(spanName string, h func(ctx context.Context, m *nats.Msg, i *{{.Type}}), spanOpts ...trace.SpanStartOption) nats.MsgHandler {
	return NewOtelExtractingHandler(
		spanName,
		func(ctx context.Context, m *nats.Msg) {
			var i {{.Type}}
			err := Unmarshal(ctx, m.Data, &i)
			if err != nil {
				return
			}
			h(ctx, m, &i)
		},
		tracing.Tracer(),
	)
}

func NewAsyncRaw{{.Type}}Handler(spanName string, h func(ctx context.Context, m *nats.Msg, i *{{.Type}}), spanOpts ...trace.SpanStartOption) nats.MsgHandler {
	return NewAsyncOtelExtractingHandler(
		spanName,
		func(ctx context.Context, m *nats.Msg) {
			var i {{.Type}}
			err := Unmarshal(ctx, m.Data, &i)
			if err != nil {
				return
			}
			h(ctx, m, &i)
		},
		tracing.Tracer(),
	)
}
`)
	if err != nil {
		panic(err)
	}

	f, err := os.Create(fmt.Sprintf("handler_%v.go", strings.ToLower(v.Type)))
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Printf("Generating handler for %v\n", v)
	err = t.Execute(f, v)
	if err != nil {
		panic(err)
	}
}
