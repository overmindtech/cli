// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: logs.proto

package sdp

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// These mirror the OpenTelemetry log severity levels
// https://opentelemetry.io/docs/specs/otel/logs/data-model/#displaying-severity
// Refer to the OpenTelemetry documentation for information on how these should
// be mapped
type LogSeverity int32

const (
	LogSeverity_UNSPECIFIED LogSeverity = 0
	LogSeverity_TRACE       LogSeverity = 1
	LogSeverity_TRACE2      LogSeverity = 2
	LogSeverity_TRACE3      LogSeverity = 3
	LogSeverity_TRACE4      LogSeverity = 4
	LogSeverity_DEBUG       LogSeverity = 5
	LogSeverity_DEBUG2      LogSeverity = 6
	LogSeverity_DEBUG3      LogSeverity = 7
	LogSeverity_DEBUG4      LogSeverity = 8
	LogSeverity_INFO        LogSeverity = 9
	LogSeverity_INFO2       LogSeverity = 10
	LogSeverity_INFO3       LogSeverity = 11
	LogSeverity_INFO4       LogSeverity = 12
	LogSeverity_WARN        LogSeverity = 13
	LogSeverity_WARN2       LogSeverity = 14
	LogSeverity_WARN3       LogSeverity = 15
	LogSeverity_WARN4       LogSeverity = 16
	LogSeverity_ERROR       LogSeverity = 17
	LogSeverity_ERROR2      LogSeverity = 18
	LogSeverity_ERROR3      LogSeverity = 19
	LogSeverity_ERROR4      LogSeverity = 20
	LogSeverity_FATAL       LogSeverity = 21
	LogSeverity_FATAL2      LogSeverity = 22
	LogSeverity_FATAL3      LogSeverity = 23
	LogSeverity_FATAL4      LogSeverity = 24
)

// Enum value maps for LogSeverity.
var (
	LogSeverity_name = map[int32]string{
		0:  "UNSPECIFIED",
		1:  "TRACE",
		2:  "TRACE2",
		3:  "TRACE3",
		4:  "TRACE4",
		5:  "DEBUG",
		6:  "DEBUG2",
		7:  "DEBUG3",
		8:  "DEBUG4",
		9:  "INFO",
		10: "INFO2",
		11: "INFO3",
		12: "INFO4",
		13: "WARN",
		14: "WARN2",
		15: "WARN3",
		16: "WARN4",
		17: "ERROR",
		18: "ERROR2",
		19: "ERROR3",
		20: "ERROR4",
		21: "FATAL",
		22: "FATAL2",
		23: "FATAL3",
		24: "FATAL4",
	}
	LogSeverity_value = map[string]int32{
		"UNSPECIFIED": 0,
		"TRACE":       1,
		"TRACE2":      2,
		"TRACE3":      3,
		"TRACE4":      4,
		"DEBUG":       5,
		"DEBUG2":      6,
		"DEBUG3":      7,
		"DEBUG4":      8,
		"INFO":        9,
		"INFO2":       10,
		"INFO3":       11,
		"INFO4":       12,
		"WARN":        13,
		"WARN2":       14,
		"WARN3":       15,
		"WARN4":       16,
		"ERROR":       17,
		"ERROR2":      18,
		"ERROR3":      19,
		"ERROR4":      20,
		"FATAL":       21,
		"FATAL2":      22,
		"FATAL3":      23,
		"FATAL4":      24,
	}
)

func (x LogSeverity) Enum() *LogSeverity {
	p := new(LogSeverity)
	*p = x
	return p
}

func (x LogSeverity) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogSeverity) Descriptor() protoreflect.EnumDescriptor {
	return file_logs_proto_enumTypes[0].Descriptor()
}

func (LogSeverity) Type() protoreflect.EnumType {
	return &file_logs_proto_enumTypes[0]
}

func (x LogSeverity) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LogSeverity.Descriptor instead.
func (LogSeverity) EnumDescriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{0}
}

type NATSGetLogRecordsResponseStatus_Status int32

const (
	NATSGetLogRecordsResponseStatus_UNSPECIFIED NATSGetLogRecordsResponseStatus_Status = 0
	// The source has started processing the request.
	NATSGetLogRecordsResponseStatus_STARTED NATSGetLogRecordsResponseStatus_Status = 1
	// The source has finished processing the request. No further messages will
	// be sent after this.
	NATSGetLogRecordsResponseStatus_FINISHED NATSGetLogRecordsResponseStatus_Status = 2
	// The source encountered an error while processing the request. No further
	// messages will be sent after this.
	NATSGetLogRecordsResponseStatus_ERRORED NATSGetLogRecordsResponseStatus_Status = 3
)

// Enum value maps for NATSGetLogRecordsResponseStatus_Status.
var (
	NATSGetLogRecordsResponseStatus_Status_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "STARTED",
		2: "FINISHED",
		3: "ERRORED",
	}
	NATSGetLogRecordsResponseStatus_Status_value = map[string]int32{
		"UNSPECIFIED": 0,
		"STARTED":     1,
		"FINISHED":    2,
		"ERRORED":     3,
	}
)

func (x NATSGetLogRecordsResponseStatus_Status) Enum() *NATSGetLogRecordsResponseStatus_Status {
	p := new(NATSGetLogRecordsResponseStatus_Status)
	*p = x
	return p
}

func (x NATSGetLogRecordsResponseStatus_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NATSGetLogRecordsResponseStatus_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_logs_proto_enumTypes[1].Descriptor()
}

func (NATSGetLogRecordsResponseStatus_Status) Type() protoreflect.EnumType {
	return &file_logs_proto_enumTypes[1]
}

func (x NATSGetLogRecordsResponseStatus_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NATSGetLogRecordsResponseStatus_Status.Descriptor instead.
func (NATSGetLogRecordsResponseStatus_Status) EnumDescriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{5, 0}
}

// This directly mirrors the Connect RPC codes that can be found here:
// https://connectrpc.com/docs/protocol/#error-codes
type SourceError_Code int32

const (
	// This is the default value and should not be used. In connectrpc, this
	// is "OK", but is not actually written out because _go_.
	SourceError_UNSPECIFIED SourceError_Code = 0
	// CodeCanceled indicates that the operation was canceled, typically by the
	// caller.
	//
	// HTTP Code: 499 Client Closed Request
	SourceError_CANCELED SourceError_Code = 1
	// CodeUnknown indicates that the operation failed for an unknown reason.
	//
	// HTTP Code: 500 Internal Server Error
	SourceError_UNKNOWN SourceError_Code = 2
	// CodeInvalidArgument indicates that client supplied an invalid argument.
	//
	// HTTP Code: 400 Bad Request
	SourceError_INVALID_ARGUMENT SourceError_Code = 3
	// CodeDeadlineExceeded indicates that deadline expired before the operation
	// could complete.
	//
	// HTTP Code: 504 Gateway Timeout
	SourceError_DEADLINE_EXCEEDED SourceError_Code = 4
	// CodeNotFound indicates that some requested entity (for example, a file or
	// directory) was not found.
	//
	// HTTP Code: 404 Not Found
	SourceError_NOT_FOUND SourceError_Code = 5
	// CodeAlreadyExists indicates that client attempted to create an entity (for
	// example, a file or directory) that already exists.
	//
	// HTTP Code: 409 Conflict
	SourceError_ALREADY_EXISTS SourceError_Code = 6
	// CodePermissionDenied indicates that the caller doesn't have permission to
	// execute the specified operation.
	//
	// HTTP Code: 403 Forbidden
	SourceError_PERMISSION_DENIED SourceError_Code = 7
	// CodeResourceExhausted indicates that some resource has been exhausted. For
	// example, a per-user quota may be exhausted or the entire file system may
	// be full.
	//
	// HTTP Code: 429 Too Many Requests
	SourceError_RESOURCE_EXHAUSTED SourceError_Code = 8
	// CodeFailedPrecondition indicates that the system is not in a state
	// required for the operation's execution.
	//
	// HTTP Code: 400 Bad Request
	SourceError_FAILED_PRECONDITION SourceError_Code = 9
	// CodeAborted indicates that operation was aborted by the system, usually
	// because of a concurrency issue such as a sequencer check failure or
	// transaction abort.
	//
	// HTTP Code: 409 Conflict
	SourceError_ABORTED SourceError_Code = 10
	// CodeOutOfRange indicates that the operation was attempted past the valid
	// range (for example, seeking past end-of-file).
	//
	// HTTP Code: 400 Bad Request
	SourceError_OUT_OF_RANGE SourceError_Code = 11
	// CodeUnimplemented indicates that the operation isn't implemented,
	// supported, or enabled in this service.
	//
	// HTTP Code: 501 Not Implemented
	SourceError_UNIMPLEMENTED SourceError_Code = 12
	// CodeInternal indicates that some invariants expected by the underlying
	// system have been broken. This code is reserved for serious errors.
	//
	// HTTP Code: 500 Internal Server Error
	SourceError_INTERNAL SourceError_Code = 13
	// CodeUnavailable indicates that the service is currently unavailable. This
	// is usually temporary, so clients can back off and retry idempotent
	// operations.
	//
	// HTTP Code: 503 Service Unavailable
	SourceError_UNAVAILABLE SourceError_Code = 14
	// CodeDataLoss indicates that the operation has resulted in unrecoverable
	// data loss or corruption.
	//
	// HTTP Code: 500 Internal Server Error
	SourceError_DATA_LOSS SourceError_Code = 15
	// CodeUnauthenticated indicates that the request does not have valid
	// authentication credentials for the operation.
	//
	// HTTP Code: 401 Unauthorized
	SourceError_UNAUTHENTICATED SourceError_Code = 16
)

// Enum value maps for SourceError_Code.
var (
	SourceError_Code_name = map[int32]string{
		0:  "UNSPECIFIED",
		1:  "CANCELED",
		2:  "UNKNOWN",
		3:  "INVALID_ARGUMENT",
		4:  "DEADLINE_EXCEEDED",
		5:  "NOT_FOUND",
		6:  "ALREADY_EXISTS",
		7:  "PERMISSION_DENIED",
		8:  "RESOURCE_EXHAUSTED",
		9:  "FAILED_PRECONDITION",
		10: "ABORTED",
		11: "OUT_OF_RANGE",
		12: "UNIMPLEMENTED",
		13: "INTERNAL",
		14: "UNAVAILABLE",
		15: "DATA_LOSS",
		16: "UNAUTHENTICATED",
	}
	SourceError_Code_value = map[string]int32{
		"UNSPECIFIED":         0,
		"CANCELED":            1,
		"UNKNOWN":             2,
		"INVALID_ARGUMENT":    3,
		"DEADLINE_EXCEEDED":   4,
		"NOT_FOUND":           5,
		"ALREADY_EXISTS":      6,
		"PERMISSION_DENIED":   7,
		"RESOURCE_EXHAUSTED":  8,
		"FAILED_PRECONDITION": 9,
		"ABORTED":             10,
		"OUT_OF_RANGE":        11,
		"UNIMPLEMENTED":       12,
		"INTERNAL":            13,
		"UNAVAILABLE":         14,
		"DATA_LOSS":           15,
		"UNAUTHENTICATED":     16,
	}
)

func (x SourceError_Code) Enum() *SourceError_Code {
	p := new(SourceError_Code)
	*p = x
	return p
}

func (x SourceError_Code) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SourceError_Code) Descriptor() protoreflect.EnumDescriptor {
	return file_logs_proto_enumTypes[2].Descriptor()
}

func (SourceError_Code) Type() protoreflect.EnumType {
	return &file_logs_proto_enumTypes[2]
}

func (x SourceError_Code) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SourceError_Code.Descriptor instead.
func (SourceError_Code) EnumDescriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{6, 0}
}

// The request to get log records from the upstream API.
type GetLogRecordsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The scope of the logs to get. This comes from the item that the LogStream
	// was attached to and ensures that the `NATSGetLogRecordsRequest` is
	// received by the same source that sent the item in the first place
	Scope string `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope,omitempty"`
	// The query that was provided in the `LogStreamDetails` . The format of this
	// is determined by the source, and will contain enough information for the
	// source to successfully query the upstream API that contains the logs
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// The start point for the logs
	From *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// The end point for the logs
	To *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
	// The maximum number of records to return. Set to zero (`0`) to return all.
	MaxRecords int32 `protobuf:"varint,5,opt,name=maxRecords,proto3" json:"maxRecords,omitempty"`
	// If the value is true, the earliest log events are returned first. If the
	// value is false, the latest log events are returned first. The default
	// value is false.
	StartFromOldest bool `protobuf:"varint,6,opt,name=startFromOldest,proto3" json:"startFromOldest,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetLogRecordsRequest) Reset() {
	*x = GetLogRecordsRequest{}
	mi := &file_logs_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLogRecordsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLogRecordsRequest) ProtoMessage() {}

func (x *GetLogRecordsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_logs_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLogRecordsRequest.ProtoReflect.Descriptor instead.
func (*GetLogRecordsRequest) Descriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{0}
}

func (x *GetLogRecordsRequest) GetScope() string {
	if x != nil {
		return x.Scope
	}
	return ""
}

func (x *GetLogRecordsRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

func (x *GetLogRecordsRequest) GetFrom() *timestamppb.Timestamp {
	if x != nil {
		return x.From
	}
	return nil
}

func (x *GetLogRecordsRequest) GetTo() *timestamppb.Timestamp {
	if x != nil {
		return x.To
	}
	return nil
}

func (x *GetLogRecordsRequest) GetMaxRecords() int32 {
	if x != nil {
		return x.MaxRecords
	}
	return 0
}

func (x *GetLogRecordsRequest) GetStartFromOldest() bool {
	if x != nil {
		return x.StartFromOldest
	}
	return false
}

// Each chunk is gonna be a page of the underlying APIs pagination.
// The source is expected to use sane defaults within the limits of the
// underlying API and SDP capabilities (message size, etc).
//
// This chunking can also be re-used for live streaming in the future.
//
// Note that the results are expected to be returned in ascending (oldest
// to newest) order.
type GetLogRecordsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Records       []*LogRecord           `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetLogRecordsResponse) Reset() {
	*x = GetLogRecordsResponse{}
	mi := &file_logs_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLogRecordsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLogRecordsResponse) ProtoMessage() {}

func (x *GetLogRecordsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_logs_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLogRecordsResponse.ProtoReflect.Descriptor instead.
func (*GetLogRecordsResponse) Descriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{1}
}

func (x *GetLogRecordsResponse) GetRecords() []*LogRecord {
	if x != nil {
		return x.Records
	}
	return nil
}

// Represents a single entry in a LogStream. Roughly a "line" in traditional
// terms, but nowadays often with more details, additional structure, etc.
//
// This is chiefly modelled on the OpenTelemetry log data model:
// https://opentelemetry.io/docs/specs/otel/logs/data-model/
type LogRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// "Time when the event occurred measured by the origin clock, i.e. the time
	// at the source."
	//
	// See https://opentelemetry.io/docs/specs/otel/logs/data-model/#field-timestamp
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=createdAt,proto3,oneof" json:"createdAt,omitempty"`
	// "Time when the event was observed by the collection system."
	// This can be used if no `createdAt` timestamp is available.
	// Client libraries are encouraged to provide a singular getter that returns
	// our best guess for ease of use: createdAt if available, else observedAt.
	//
	// See https://opentelemetry.io/docs/specs/otel/logs/data-model/#field-observedtimestamp
	ObservedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=observedAt,proto3,oneof" json:"observedAt,omitempty"`
	// See the definitions in
	// https://opentelemetry.io/docs/specs/otel/logs/data-model/#field-severitynumber
	// Each source should document its mapping to this standard, e.g. following
	// the examples in
	// https://opentelemetry.io/docs/specs/otel/logs/data-model-appendix/#appendix-b-severitynumber-example-mappings
	//
	// See https://opentelemetry.io/docs/specs/otel/logs/data-model/#field-severitynumber
	Severity LogSeverity `protobuf:"varint,3,opt,name=severity,proto3,enum=logs.LogSeverity" json:"severity,omitempty"`
	// the string form of the `body`. Can be empty if the upstream API only
	// provides structured records. A Source can decide in this case to render a
	// default field here if available.
	//
	// See https://opentelemetry.io/docs/specs/otel/logs/data-model/#field-body
	Body string `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
	// "Describes the source of the log", as provided by the upstream API.
	// This is arbitrary metadata from the upstream API as interpreted by the
	// source. May be empty. Should use standard OTel attribute names where
	// applicable.
	//
	// See https://opentelemetry.io/docs/specs/otel/logs/data-model/#field-resource
	Resource *structpb.Struct `protobuf:"bytes,5,opt,name=resource,proto3,oneof" json:"resource,omitempty"`
	// "Additional information about the specific event occurrence." This is
	// arbitrary metadata from the upstream API as interpreted by the source.
	// May be empty, may contain error and exception attributes.
	//
	// See https://opentelemetry.io/docs/specs/otel/logs/data-model/#field-attributes
	Attributes    *structpb.Struct `protobuf:"bytes,6,opt,name=attributes,proto3,oneof" json:"attributes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogRecord) Reset() {
	*x = LogRecord{}
	mi := &file_logs_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRecord) ProtoMessage() {}

func (x *LogRecord) ProtoReflect() protoreflect.Message {
	mi := &file_logs_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRecord.ProtoReflect.Descriptor instead.
func (*LogRecord) Descriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{2}
}

func (x *LogRecord) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *LogRecord) GetObservedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ObservedAt
	}
	return nil
}

func (x *LogRecord) GetSeverity() LogSeverity {
	if x != nil {
		return x.Severity
	}
	return LogSeverity_UNSPECIFIED
}

func (x *LogRecord) GetBody() string {
	if x != nil {
		return x.Body
	}
	return ""
}

func (x *LogRecord) GetResource() *structpb.Struct {
	if x != nil {
		return x.Resource
	}
	return nil
}

func (x *LogRecord) GetAttributes() *structpb.Struct {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// A quick passthrough to keep the NATS message format consistent.
type NATSGetLogRecordsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Request       *GetLogRecordsRequest  `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NATSGetLogRecordsRequest) Reset() {
	*x = NATSGetLogRecordsRequest{}
	mi := &file_logs_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NATSGetLogRecordsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NATSGetLogRecordsRequest) ProtoMessage() {}

func (x *NATSGetLogRecordsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_logs_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NATSGetLogRecordsRequest.ProtoReflect.Descriptor instead.
func (*NATSGetLogRecordsRequest) Descriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{3}
}

func (x *NATSGetLogRecordsRequest) GetRequest() *GetLogRecordsRequest {
	if x != nil {
		return x.Request
	}
	return nil
}

type NATSGetLogRecordsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Content:
	//
	//	*NATSGetLogRecordsResponse_Status
	//	*NATSGetLogRecordsResponse_Response
	Content       isNATSGetLogRecordsResponse_Content `protobuf_oneof:"content"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NATSGetLogRecordsResponse) Reset() {
	*x = NATSGetLogRecordsResponse{}
	mi := &file_logs_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NATSGetLogRecordsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NATSGetLogRecordsResponse) ProtoMessage() {}

func (x *NATSGetLogRecordsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_logs_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NATSGetLogRecordsResponse.ProtoReflect.Descriptor instead.
func (*NATSGetLogRecordsResponse) Descriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{4}
}

func (x *NATSGetLogRecordsResponse) GetContent() isNATSGetLogRecordsResponse_Content {
	if x != nil {
		return x.Content
	}
	return nil
}

func (x *NATSGetLogRecordsResponse) GetStatus() *NATSGetLogRecordsResponseStatus {
	if x != nil {
		if x, ok := x.Content.(*NATSGetLogRecordsResponse_Status); ok {
			return x.Status
		}
	}
	return nil
}

func (x *NATSGetLogRecordsResponse) GetResponse() *GetLogRecordsResponse {
	if x != nil {
		if x, ok := x.Content.(*NATSGetLogRecordsResponse_Response); ok {
			return x.Response
		}
	}
	return nil
}

type isNATSGetLogRecordsResponse_Content interface {
	isNATSGetLogRecordsResponse_Content()
}

type NATSGetLogRecordsResponse_Status struct {
	// The status of the request. This is sent before any log records are
	// sent, and then if an error occurs, or the request is finished. This
	// provides signalling of the "method call" over NATS.
	Status *NATSGetLogRecordsResponseStatus `protobuf:"bytes,1,opt,name=status,proto3,oneof"`
}

type NATSGetLogRecordsResponse_Response struct {
	// A set of log records (lines). These should be batched in whatever way
	// that the upstream provider batches them. For example if the API that
	// you are pulling the logs from returns them in pages of 50, then you
	// should return 50 log records in each response, and send the response
	// on before requesting the next page from the API.
	Response *GetLogRecordsResponse `protobuf:"bytes,2,opt,name=response,proto3,oneof"`
}

func (*NATSGetLogRecordsResponse_Status) isNATSGetLogRecordsResponse_Content() {}

func (*NATSGetLogRecordsResponse_Response) isNATSGetLogRecordsResponse_Content() {}

type NATSGetLogRecordsResponseStatus struct {
	state  protoimpl.MessageState                 `protogen:"open.v1"`
	Status NATSGetLogRecordsResponseStatus_Status `protobuf:"varint,1,opt,name=status,proto3,enum=logs.NATSGetLogRecordsResponseStatus_Status" json:"status,omitempty"`
	// Only populated when the status is ERRORED
	Error         *SourceError `protobuf:"bytes,2,opt,name=error,proto3,oneof" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NATSGetLogRecordsResponseStatus) Reset() {
	*x = NATSGetLogRecordsResponseStatus{}
	mi := &file_logs_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NATSGetLogRecordsResponseStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NATSGetLogRecordsResponseStatus) ProtoMessage() {}

func (x *NATSGetLogRecordsResponseStatus) ProtoReflect() protoreflect.Message {
	mi := &file_logs_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NATSGetLogRecordsResponseStatus.ProtoReflect.Descriptor instead.
func (*NATSGetLogRecordsResponseStatus) Descriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{5}
}

func (x *NATSGetLogRecordsResponseStatus) GetStatus() NATSGetLogRecordsResponseStatus_Status {
	if x != nil {
		return x.Status
	}
	return NATSGetLogRecordsResponseStatus_UNSPECIFIED
}

func (x *NATSGetLogRecordsResponseStatus) GetError() *SourceError {
	if x != nil {
		return x.Error
	}
	return nil
}

type SourceError struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The error code
	Code SourceError_Code `protobuf:"varint,1,opt,name=code,proto3,enum=logs.SourceError_Code" json:"code,omitempty"`
	// The error message
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// Whether this error comes from the upstream API or not. Errors that come
	// from the upstream API will result in the user-facing RPC returning a
	// `code.Aborted` error, with the `NatsError` embedded in the `Detail`
	// field. This differentiates between errors that were part of Overmind
	// (like the source panicking) and errors that come from the upstream (like
	// Datadog having an outage)
	Upstream      bool `protobuf:"varint,3,opt,name=upstream,proto3" json:"upstream,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SourceError) Reset() {
	*x = SourceError{}
	mi := &file_logs_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceError) ProtoMessage() {}

func (x *SourceError) ProtoReflect() protoreflect.Message {
	mi := &file_logs_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceError.ProtoReflect.Descriptor instead.
func (*SourceError) Descriptor() ([]byte, []int) {
	return file_logs_proto_rawDescGZIP(), []int{6}
}

func (x *SourceError) GetCode() SourceError_Code {
	if x != nil {
		return x.Code
	}
	return SourceError_UNSPECIFIED
}

func (x *SourceError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *SourceError) GetUpstream() bool {
	if x != nil {
		return x.Upstream
	}
	return false
}

var File_logs_proto protoreflect.FileDescriptor

const file_logs_proto_rawDesc = "" +
	"\n" +
	"\n" +
	"logs.proto\x12\x04logs\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xe8\x01\n" +
	"\x14GetLogRecordsRequest\x12\x14\n" +
	"\x05scope\x18\x01 \x01(\tR\x05scope\x12\x14\n" +
	"\x05query\x18\x02 \x01(\tR\x05query\x12.\n" +
	"\x04from\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x04from\x12*\n" +
	"\x02to\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x02to\x12\x1e\n" +
	"\n" +
	"maxRecords\x18\x05 \x01(\x05R\n" +
	"maxRecords\x12(\n" +
	"\x0fstartFromOldest\x18\x06 \x01(\bR\x0fstartFromOldest\"B\n" +
	"\x15GetLogRecordsResponse\x12)\n" +
	"\arecords\x18\x01 \x03(\v2\x0f.logs.LogRecordR\arecords\"\xff\x02\n" +
	"\tLogRecord\x12=\n" +
	"\tcreatedAt\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\tcreatedAt\x88\x01\x01\x12?\n" +
	"\n" +
	"observedAt\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampH\x01R\n" +
	"observedAt\x88\x01\x01\x12-\n" +
	"\bseverity\x18\x03 \x01(\x0e2\x11.logs.LogSeverityR\bseverity\x12\x12\n" +
	"\x04body\x18\x04 \x01(\tR\x04body\x128\n" +
	"\bresource\x18\x05 \x01(\v2\x17.google.protobuf.StructH\x02R\bresource\x88\x01\x01\x12<\n" +
	"\n" +
	"attributes\x18\x06 \x01(\v2\x17.google.protobuf.StructH\x03R\n" +
	"attributes\x88\x01\x01B\f\n" +
	"\n" +
	"_createdAtB\r\n" +
	"\v_observedAtB\v\n" +
	"\t_resourceB\r\n" +
	"\v_attributes\"P\n" +
	"\x18NATSGetLogRecordsRequest\x124\n" +
	"\arequest\x18\x01 \x01(\v2\x1a.logs.GetLogRecordsRequestR\arequest\"\xa2\x01\n" +
	"\x19NATSGetLogRecordsResponse\x12?\n" +
	"\x06status\x18\x01 \x01(\v2%.logs.NATSGetLogRecordsResponseStatusH\x00R\x06status\x129\n" +
	"\bresponse\x18\x02 \x01(\v2\x1b.logs.GetLogRecordsResponseH\x00R\bresponseB\t\n" +
	"\acontent\"\xe2\x01\n" +
	"\x1fNATSGetLogRecordsResponseStatus\x12D\n" +
	"\x06status\x18\x01 \x01(\x0e2,.logs.NATSGetLogRecordsResponseStatus.StatusR\x06status\x12,\n" +
	"\x05error\x18\x02 \x01(\v2\x11.logs.SourceErrorH\x00R\x05error\x88\x01\x01\"A\n" +
	"\x06Status\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\v\n" +
	"\aSTARTED\x10\x01\x12\f\n" +
	"\bFINISHED\x10\x02\x12\v\n" +
	"\aERRORED\x10\x03B\b\n" +
	"\x06_error\"\xb1\x03\n" +
	"\vSourceError\x12*\n" +
	"\x04code\x18\x01 \x01(\x0e2\x16.logs.SourceError.CodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x1a\n" +
	"\bupstream\x18\x03 \x01(\bR\bupstream\"\xbf\x02\n" +
	"\x04Code\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\f\n" +
	"\bCANCELED\x10\x01\x12\v\n" +
	"\aUNKNOWN\x10\x02\x12\x14\n" +
	"\x10INVALID_ARGUMENT\x10\x03\x12\x15\n" +
	"\x11DEADLINE_EXCEEDED\x10\x04\x12\r\n" +
	"\tNOT_FOUND\x10\x05\x12\x12\n" +
	"\x0eALREADY_EXISTS\x10\x06\x12\x15\n" +
	"\x11PERMISSION_DENIED\x10\a\x12\x16\n" +
	"\x12RESOURCE_EXHAUSTED\x10\b\x12\x17\n" +
	"\x13FAILED_PRECONDITION\x10\t\x12\v\n" +
	"\aABORTED\x10\n" +
	"\x12\x10\n" +
	"\fOUT_OF_RANGE\x10\v\x12\x11\n" +
	"\rUNIMPLEMENTED\x10\f\x12\f\n" +
	"\bINTERNAL\x10\r\x12\x0f\n" +
	"\vUNAVAILABLE\x10\x0e\x12\r\n" +
	"\tDATA_LOSS\x10\x0f\x12\x13\n" +
	"\x0fUNAUTHENTICATED\x10\x10*\xb0\x02\n" +
	"\vLogSeverity\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\t\n" +
	"\x05TRACE\x10\x01\x12\n" +
	"\n" +
	"\x06TRACE2\x10\x02\x12\n" +
	"\n" +
	"\x06TRACE3\x10\x03\x12\n" +
	"\n" +
	"\x06TRACE4\x10\x04\x12\t\n" +
	"\x05DEBUG\x10\x05\x12\n" +
	"\n" +
	"\x06DEBUG2\x10\x06\x12\n" +
	"\n" +
	"\x06DEBUG3\x10\a\x12\n" +
	"\n" +
	"\x06DEBUG4\x10\b\x12\b\n" +
	"\x04INFO\x10\t\x12\t\n" +
	"\x05INFO2\x10\n" +
	"\x12\t\n" +
	"\x05INFO3\x10\v\x12\t\n" +
	"\x05INFO4\x10\f\x12\b\n" +
	"\x04WARN\x10\r\x12\t\n" +
	"\x05WARN2\x10\x0e\x12\t\n" +
	"\x05WARN3\x10\x0f\x12\t\n" +
	"\x05WARN4\x10\x10\x12\t\n" +
	"\x05ERROR\x10\x11\x12\n" +
	"\n" +
	"\x06ERROR2\x10\x12\x12\n" +
	"\n" +
	"\x06ERROR3\x10\x13\x12\n" +
	"\n" +
	"\x06ERROR4\x10\x14\x12\t\n" +
	"\x05FATAL\x10\x15\x12\n" +
	"\n" +
	"\x06FATAL2\x10\x16\x12\n" +
	"\n" +
	"\x06FATAL3\x10\x17\x12\n" +
	"\n" +
	"\x06FATAL4\x10\x182Y\n" +
	"\vLogsService\x12J\n" +
	"\rGetLogRecords\x12\x1a.logs.GetLogRecordsRequest\x1a\x1b.logs.GetLogRecordsResponse0\x01B.Z,github.com/overmindtech/workspace/sdp-go;sdpb\x06proto3"

var (
	file_logs_proto_rawDescOnce sync.Once
	file_logs_proto_rawDescData []byte
)

func file_logs_proto_rawDescGZIP() []byte {
	file_logs_proto_rawDescOnce.Do(func() {
		file_logs_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_logs_proto_rawDesc), len(file_logs_proto_rawDesc)))
	})
	return file_logs_proto_rawDescData
}

var file_logs_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_logs_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_logs_proto_goTypes = []any{
	(LogSeverity)(0), // 0: logs.LogSeverity
	(NATSGetLogRecordsResponseStatus_Status)(0), // 1: logs.NATSGetLogRecordsResponseStatus.Status
	(SourceError_Code)(0),                       // 2: logs.SourceError.Code
	(*GetLogRecordsRequest)(nil),                // 3: logs.GetLogRecordsRequest
	(*GetLogRecordsResponse)(nil),               // 4: logs.GetLogRecordsResponse
	(*LogRecord)(nil),                           // 5: logs.LogRecord
	(*NATSGetLogRecordsRequest)(nil),            // 6: logs.NATSGetLogRecordsRequest
	(*NATSGetLogRecordsResponse)(nil),           // 7: logs.NATSGetLogRecordsResponse
	(*NATSGetLogRecordsResponseStatus)(nil),     // 8: logs.NATSGetLogRecordsResponseStatus
	(*SourceError)(nil),                         // 9: logs.SourceError
	(*timestamppb.Timestamp)(nil),               // 10: google.protobuf.Timestamp
	(*structpb.Struct)(nil),                     // 11: google.protobuf.Struct
}
var file_logs_proto_depIdxs = []int32{
	10, // 0: logs.GetLogRecordsRequest.from:type_name -> google.protobuf.Timestamp
	10, // 1: logs.GetLogRecordsRequest.to:type_name -> google.protobuf.Timestamp
	5,  // 2: logs.GetLogRecordsResponse.records:type_name -> logs.LogRecord
	10, // 3: logs.LogRecord.createdAt:type_name -> google.protobuf.Timestamp
	10, // 4: logs.LogRecord.observedAt:type_name -> google.protobuf.Timestamp
	0,  // 5: logs.LogRecord.severity:type_name -> logs.LogSeverity
	11, // 6: logs.LogRecord.resource:type_name -> google.protobuf.Struct
	11, // 7: logs.LogRecord.attributes:type_name -> google.protobuf.Struct
	3,  // 8: logs.NATSGetLogRecordsRequest.request:type_name -> logs.GetLogRecordsRequest
	8,  // 9: logs.NATSGetLogRecordsResponse.status:type_name -> logs.NATSGetLogRecordsResponseStatus
	4,  // 10: logs.NATSGetLogRecordsResponse.response:type_name -> logs.GetLogRecordsResponse
	1,  // 11: logs.NATSGetLogRecordsResponseStatus.status:type_name -> logs.NATSGetLogRecordsResponseStatus.Status
	9,  // 12: logs.NATSGetLogRecordsResponseStatus.error:type_name -> logs.SourceError
	2,  // 13: logs.SourceError.code:type_name -> logs.SourceError.Code
	3,  // 14: logs.LogsService.GetLogRecords:input_type -> logs.GetLogRecordsRequest
	4,  // 15: logs.LogsService.GetLogRecords:output_type -> logs.GetLogRecordsResponse
	15, // [15:16] is the sub-list for method output_type
	14, // [14:15] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_logs_proto_init() }
func file_logs_proto_init() {
	if File_logs_proto != nil {
		return
	}
	file_logs_proto_msgTypes[2].OneofWrappers = []any{}
	file_logs_proto_msgTypes[4].OneofWrappers = []any{
		(*NATSGetLogRecordsResponse_Status)(nil),
		(*NATSGetLogRecordsResponse_Response)(nil),
	}
	file_logs_proto_msgTypes[5].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_logs_proto_rawDesc), len(file_logs_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_logs_proto_goTypes,
		DependencyIndexes: file_logs_proto_depIdxs,
		EnumInfos:         file_logs_proto_enumTypes,
		MessageInfos:      file_logs_proto_msgTypes,
	}.Build()
	File_logs_proto = out.File
	file_logs_proto_goTypes = nil
	file_logs_proto_depIdxs = nil
}
